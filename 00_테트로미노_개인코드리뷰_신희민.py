"""
소요 시간 : 3시간 / 시도 횟수 : 7회
타임라인 : 이해 및 구상 (30분) - 구현 (30분) - 디버깅 (120분: 시험 외 시간 포함)
한줄평 : 연습할 때는 괜찮은데, 시험때만 되면 다급해져 예전에 안좋았던 습관이 그대로 나온다

[구상]
- 아이디어가 도저히 떠오르지 않아 구상 시간이 많이 소요
- 만들어지는 도형이 많을 줄 알고 각 도형을 회전, 반전하는 함수를 만들어 적용 -> 누락되는 도형이 생김 ex) 좌우반전
- 이해가 안될 때 머리로 상상하기보다 그림을 먼저 다 그려봤다면 개수가 얼마 되지 않음을 알았을거고, 좌표간 규칙성 파악도 수월했을 듯
- 구상 미스 : 돌린 도형들을 상하반전만 하면 좌우반전은 고려안해도 될 줄 알았는데 아니었음

[구현]
- 검사 좌표의 인덱스를 지정하는데 실수가 많았음
- 도형 내 정사각형들의 상대좌표를 표현하는데 실수가 많았음 
- 속도가 너무 느려 디버깅 시간이 거의 없었음: 구현 속도 올릴 필요 있다

[디버깅]
- 검사 종료 좌표를 N-2, M-2로 설정했는데 마지막 좌표라도 도형이 올 수 있음을 오픈 테케를 통해 확인 후 수정
- 이후 히든 테케가 모두 실패하여 이리저리 수정 시도하였으나 실패 -> 코드를 고칠게 아니라 로직을 점검해야했음

[후기]
- 단순하게 할 수 있는 문제를 어렵게 생각: 굳이 돌리고 뒤집는 작업을 하지말고 (실수 유발 多), 19개 밖에 안되니까 그냥 하드코딩이 맘 편함
    => 앞으로 30개 이하는 규칙 잘 안보이면 하드 코딩
- 구현은 정확하면서도 빠르게! 천천히 하면 디버깅 시간 너무 모자라고, 피치 못하게 구상을 엎어야 하는 경우 시간 절대적으로 부족
    => 1/3 시간안에 구현까지 마치는 것을 목표로 하자
- 인덱스 실수가 많은 것은 구상에서 정확히 정의하지 않았기 때문
    => 그림으로 표시 + 범위 글로 적는 습관 들이자.
- 오픈 테케에 끼워맞출 생각하지 말고 로직 자체를 견고하게 하자
- 도형 문제에 약하기 때문에 쉬운 도형 문제부터 풀면서 감각을 키우자

[리펙토링 포인트]
- 돌리고 뒤집는 동작을 함수로 분리해서 코드 구성을 깔끔하게 했다 (비록 틀렷지만,,)
- 기준 좌표 (0, 0)은 저장하지 않아도 무관하다.
"""

N, M = map(int, input().split())  # Refactoring: 앞에 두 값은 N과 M으로, 나머지는 rest 라는 리스트에 담김
arr = [list(map(int, input().split())) for _ in range(N)]

shapes = [[(0,1), (0,2), (0,3)], [(1,0), (2,0), (3,0)], # 1x4 형태
        [(0,1), (1,0), (1,1)], # 2x2형태
        [(1,0),(1,1),(2,1)], [(0,-1), (1,-1), (1,-2)], # ㄹ자 (회전)
        [(1,0), (1,-1), (2,-1)],[(0,1), (1,1), (1,2)], # ㄹ자 (대칭)
        [(1,0), (2,0), (2,1)], [(0,1), (0,2), (1,0)], # ㄴ자 (회전)
        [(0,1),(1,1), (2,1)], [(0,1), (0,2), (-1,2)],
        [(1,0),(2,0),(2,-1)],[(0,1),(0,2),(1,2)], # ㄴ자 (대칭)
        [(1,0),(2,0),(0,1)], [(1,0),(1,1),(1,2)],
        [(1,0),(1,1),(1,-1)], [(1,0),(1,1),(2,0)], # ㅗ자(회전)
        [(0,-1),(1,0),(0,1)],[(0,1),(-1,1),(1,1)]]
# Refactoring : (0, 0)은 곧 (i, j) 가 되기 때문에 굳이 상대좌표에 포함할 필요 없음

ANS = 0
for i in range(N):
    for j in range(M): # 각각 검사할 좌표
        for shape in shapes: # 각 모양별로
            sm = arr[i][j]  # 최대값으로 갱신할 합산값 (※ 위치 주의: 각 도형(모양)마다 합계 확인/갱신해줘야함)
            for di, dj in shape: # 해당 모양의 상대 좌표
                ni, nj = i + di, j + dj # 절다 좌표 구하기

                if 0 <= ni < N and 0 <= nj < M: # 범위 체크
                    # continue
                    sm += arr[ni][nj]  # 좌표의 숫자 합산 
                else: # 범위 밖이면
                    sm = 0
                    break # 해당 도형은 배치할 수 없음
            ANS = max(ANS, sm) # 최대값 갱신

print(ANS)
