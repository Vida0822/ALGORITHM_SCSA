"""
[개인 코드 리뷰]
한줄평:
1. 구현(시뮬레이션)문제는 임의로 로직을 단축하지 말고 문제에 드러난 순서, 조건 그대로 구현해야한다
2. 손코딩에 다음을 무조건 포함 : 1) 시나리오 로직 2) 코드 로직(필요한 자료형**) 3) 오픈 TC 시뮬레이션

소요 시간: 150분
타임라인 :
1차 시도) 구상 : 10분 - 구현 : 20분  - 디버깅 : 60분
2차 시도) 재구상 : 20분 - 구현 : 10분 - 디버깅 10분

[구상]
+) 각 이동/올리기에 대한 조건을 넘버링으로 명확히 표시
-) 문제에 언급된 순서를 지키지 않고 임의로 시뮬레이션 순서를 바꿈 (**치명적)
-) '시나리오 로직'을 기준으로 손 코딩 (실제 코드 로직을 고려하지 않음)
-) 오픈 테스트케이스를 시뮬레이션 해보지 않아 로직 구멍을 뒤늦게 발견

[구현]
-) 단계별로 테스트하지 않고 전부 구현한 후 테스트하여 로직이 잘못된 걸 뒤늦게 알았고, 재구상하기에는 시간이 부족
-) 필요한 자료형들을 미리 고려하지 않아 구현하면서 임의로 추가/삭제 -> 로직상 구멍 발생
-) 벨트에 오래있었던 로봇부터 검사를 해야했는데 검사 순서 실수

[디버깅]
-) 구성 자체가 잘못된 것을 인지하지 못하고 코드 부분 부분을 수정 (의미없는 시간 낭비)
    => 디버깅 10분 이상 시도 후 해결 한되면 무조건 로직 점검!
-) 무분별한 조건문 사용으로 잘못된 로직 보완하려함

"""

N, K = map(int, input().split())
A = [0]+list(map(int, input().split())) # 패딩 필요
L = 2*N

# 0. 시뮬레이션 준비 (필요한 자료형)
ans = 0
lst = [0]*(L+1)

# 1. 시뮬레이션 실행
while True:
    ans += 1  # 일자 증가

    # [0] 벨트 이동
    lst.insert(1, lst.pop())
    A.insert(1, A.pop())
    if lst[N] == 1:
        lst[N] = 0

    # [1] 로봇 이동
    cp_lst = [0]*(L+1)
    for i in range(L, -1, -1):
        if lst[i] == 1 :
            n = (i+1) % L if (i+1) % L != 0 else 2*N
            if lst[n] == 0 and A[n] >= 1: # 로봇 없음 & 내구도 있음
                lst[i] = 0
                lst[n] = 1
                A[n] -= 1
    if lst[N] == 1:
        lst[N] = 0

    # [2] 로봇 올리기
    if lst[1] == 0 and A[1] >= 1 :
        lst[1] = 1
        A[1] -= 1

    # [3] 내구도 체크
    cnt = 0
    # print(A)
    for i in range(1, L+1):
        if A[i] <= 0 :
            cnt += 1
    if cnt >= K :
        break

# 2. 시뮬레이션 정답 출력
print(ans)